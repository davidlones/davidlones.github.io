<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Interactive Star Map</title>
  <style>
    :root {
      --bg-0: #070913;
      --bg-1: #0b0d16;
      --fg: #e8eef9;
      --muted: #90a4c6;
      --accent: #5bd1ff;
      --glass: rgba(15,18,30,.65);
      --glass-stroke: rgba(255,255,255,.15);
      --shadow: 0 10px 24px rgba(0,0,0,.45);
      --blur: saturate(1.15) blur(6px);
    }

    /* Full-bleed cosmic backdrop */
    html, body { height: 100%; }
    body {
      margin: 0;
      color: var(--fg);
      font: 14px/1.35 system-ui, Segoe UI, Roboto, Ubuntu, Cantarell, Helvetica, Arial, sans-serif;
      background:
        radial-gradient(1200px 600px at 20% -10%, #101429 0%, transparent 60%),
        radial-gradient(900px 600px at 80% 110%, #101a33 0%, transparent 55%),
        linear-gradient(180deg, var(--bg-0), var(--bg-1));
      overflow: hidden;
    }

    /* Subtle starfield */
    .stars::before, .stars::after {
      content: "";
      position: fixed; inset: 0;
      pointer-events: none;
      background-image:
        radial-gradient(1px 1px at 10% 20%, rgba(255,255,255,.9) 99%, transparent),
        radial-gradient(1px 1px at 30% 40%, rgba(255,255,255,.7) 99%, transparent),
        radial-gradient(1px 1px at 70% 30%, rgba(255,255,255,.8) 99%, transparent),
        radial-gradient(1px 1px at 80% 80%, rgba(255,255,255,.6) 99%, transparent),
        radial-gradient(1px 1px at 45% 75%, rgba(255,255,255,.7) 99%, transparent);
      background-repeat: repeat;
      background-size: 400px 400px, 500px 500px, 450px 450px, 600px 600px, 550px 550px;
      opacity: .35;
    }
    .stars::after { transform: scale(1.2); opacity: .18; }

    /* Root layout: the map occupies everything */
    #root {
      height: 100%;
      display: grid;
      grid-template-rows: 1fr; /* controls, if any, float—not reserved space */
    }

    /* Shell forces children (the React app) to stretch */
    .shell {
      position: relative;
      height: 100%;
      width: 100%;
      display: grid;
      grid-template-rows: 1fr;
    }
    .stage,
    .stage > * {
      height: 100% !important;
      width: 100% !important;
    }

    /* HARD OVERRIDES so small canvases/images expand */
    #root canvas,
    #root svg {
      display: block !important;
      width: 100% !important;
      height: 100% !important;
      max-width: none !important;
      max-height: none !important;
    }
    #root img {
      display: block !important;
      width: 100% !important;
      height: auto !important;
    }

    /* Any obvious “control”-y containers get compacted and floated */
    #root .controls,
    #root .toolbar,
    #root [role="toolbar"] {
      position: absolute !important;
      inset: 16px auto auto 16px !important;
      z-index: 3;
      max-width: 360px;
      max-height: 60vh;
      overflow: auto;
      padding: 10px 12px;
      border-radius: 12px;
      color: var(--fg);
      background: var(--glass);
      -webkit-backdrop-filter: var(--blur);
      backdrop-filter: var(--blur);
      box-shadow: var(--shadow);
      border: 1px solid var(--glass-stroke);
      font-size: 12px;
    }
    #root .controls * { color: inherit; }
    #root .controls input,
    #root .controls select,
    #root .controls button {
      font: inherit;
    }

    /* Wrapper HUD: tiny corner buttons */
    .hud {
      position: absolute; inset: 16px 16px auto auto;
      display: grid; gap: 8px;
      z-index: 5;
    }
    .hud button {
      appearance: none;
      border: 1px solid var(--glass-stroke);
      background: var(--glass);
      color: var(--fg);
      border-radius: 10px;
      padding: 8px 10px;
      cursor: pointer;
      box-shadow: var(--shadow);
      -webkit-backdrop-filter: var(--blur);
      backdrop-filter: var(--blur);
    }
    .hud button:hover { border-color: rgba(255,255,255,.35); }

    /* Boot splash */
    .boot {
      position: fixed; inset: 0;
      display: grid; place-items: center;
      color: var(--muted);
      font-size: 14px;
      letter-spacing: .3px;
      background: linear-gradient(180deg, rgba(11,13,22,.6), rgba(11,13,22,.3));
      z-index: 9;
    }
    .boot .card {
      padding: 14px 16px;
      border-radius: 12px;
      background: var(--glass);
      border: 1px solid var(--glass-stroke);
      -webkit-backdrop-filter: var(--blur);
      backdrop-filter: var(--blur);
      box-shadow: var(--shadow);
    }

    /* Small screens: keep controls slim */
    @media (max-width: 640px) {
      #root .controls,
      #root .toolbar,
      #root [role="toolbar"] {
        inset: auto 12px 12px 12px !important;
        max-width: calc(100% - 24px);
      }
      .hud { inset: 12px 12px auto auto; }
    }
  </style>

  <!-- React (UMD) + Babel for on-the-fly JSX -->
  <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body class="stars">
  <div id="root">
    <div class="shell">
      <div class="stage" id="stage"></div>

      <!-- Tiny wrapper-level HUD (optional) -->
      <div class="hud" aria-label="Wrapper HUD">
        <button id="fit-toggle" title="Toggle fit mode (contain/fill)">Fit: contain</button>
        <button id="controls-toggle" title="Show/Hide in-app controls">Controls</button>
      </div>
    </div>
  </div>

  <div class="boot" id="boot">
    <div class="card">Loading Interactive Star Map…</div>
  </div>

  <script>
    (async function () {
      const $ = (s) => document.querySelector(s);
      const rootEl = document.getElementById('stage');

      try {
        // Fetch the uploaded JSX exactly as provided
        const resp = await fetch('./interactive_star_map_v_2_react_web_app.jsx', { cache: 'no-store' });
        if (!resp.ok) throw new Error('HTTP ' + resp.status + ' while fetching JSX');
        const src0 = await resp.text();

        // Patch typical ESM import/exports into UMD globals for this runtime
        let src = src0
          .replace(/^\s*import\s+React[^;]*?from\s+["']react["'];?\s*/m,
                   "const { useEffect, useMemo, useRef, useState } = React;")
          .replace(/\bexport\s+default\s+function\s+([A-Za-z0-9_]+)?\s*\(/,
                   (m, name) => `function ${name || 'App'}(`)
          .replace(/\bexport\s+default\s+([A-Za-z0-9_]+)\s*;/, 'window.__StarMapApp = $1;');

        // Ensure there's a global App even if export default wasn't used
        if (!/window\.__StarMapApp/.test(src)) {
          src += `\n;window.__StarMapApp = typeof App !== 'undefined' ? App : (typeof StarMapApp !== 'undefined' ? StarMapApp : undefined);`;
        }

        // Transpile JSX → JS
        const out = Babel.transform(src, { presets: ['react'] }).code;

        // Evaluate in page scope
        (new Function(out))();

        if (!window.__StarMapApp) throw new Error('No default export detected (App)');

        // A wrapper component that guarantees full-bleed sizing
        function ShellApp() {
          return React.createElement('div', {
            style: {
              position: 'absolute',
              inset: 0,
              display: 'grid'
            }
          }, React.createElement(window.__StarMapApp));
        }

        const r = ReactDOM.createRoot(rootEl);
        r.render(React.createElement(ShellApp));

        // Post-mount: force any canvas/svg/img to adopt full-bleed sizing
        const forceFullBleed = () => {
          const nodes = rootEl.querySelectorAll('canvas,svg,img');
          nodes.forEach(n => {
            n.style.display = 'block';
            n.style.width = '100%';
            // Prefer height 100% for vector/canvas; images keep aspect
            if (n.tagName.toLowerCase() !== 'img') {
              n.style.height = '100%';
            }
          });

          // If the app used inline width/height attributes on canvas/svg, override
          rootEl.querySelectorAll('canvas[width], canvas[height], svg[width], svg[height]').forEach(n => {
            n.removeAttribute('width');
            n.removeAttribute('height');
          });

          // If the app has an obvious "controls" container, ensure it's floating & compact
          const ctrl = rootEl.querySelector('.controls, .toolbar, [role="toolbar"]');
          if (ctrl) ctrl.classList.add('controls'); // adopt wrapper styles
        };

        // Observe size/DOM changes to keep things stretched
        const ro = new ResizeObserver(forceFullBleed);
        ro.observe(rootEl);
        new MutationObserver(forceFullBleed).observe(rootEl, { childList: true, subtree: true });

        // Initial nudge
        forceFullBleed();

      } catch (err) {
        const boot = document.getElementById('boot');
        if (boot) boot.innerHTML = `<div class="card">Failed to load the Star Map:<br><small>${(err && err.message) || err}</small></div>`;
        console.error(err);
        return;
      }

      // Remove boot splash
      const boot = document.getElementById('boot');
      if (boot) boot.remove();

      // Wrapper HUD: helpful toggles that don't depend on internals
      const stage = document.getElementById('stage');
      let fitContain = true;
      const applyFit = () => {
        // contain = preserve aspect inside viewport; fill = cover (croppable)
        stage.style.objectFit = fitContain ? 'contain' : 'cover';
        // For canvases/svgs we emulate via container sizing
        stage.style.alignItems = fitContain ? 'center' : 'stretch';
        stage.style.justifyItems = fitContain ? 'center' : 'stretch';
        document.getElementById('fit-toggle').textContent = `Fit: ${fitContain ? 'contain' : 'fill'}`;
      };
      stage.style.display = 'grid';
      applyFit();

      document.getElementById('fit-toggle').addEventListener('click', () => {
        fitContain = !fitContain;
        applyFit();
      });

      document.getElementById('controls-toggle').addEventListener('click', () => {
        const c = stage.querySelector('.controls, .toolbar, [role="toolbar"]');
        if (!c) return;
        const hidden = c.style.display === 'none';
        c.style.display = hidden ? '' : 'none';
      });

      // Keep canvases crisp on DPR changes / resizes
      const handleResize = () => {
        window.dispatchEvent(new Event('resize'));
      };
      window.addEventListener('resize', handleResize);
      matchMedia(`(resolution: ${window.devicePixelRatio}dppx)`).addEventListener?.('change', handleResize);
    })();
  </script>
</body>
</html>
