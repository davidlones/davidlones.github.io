
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Quantum Board v2 (Canvas)</title>
<style>
  html, body { height:100%; margin:0; }
  body {
    background: linear-gradient(135deg, #c17a5c 0%, #9d6b53 100%);
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif;
    display:flex; flex-direction:column; align-items:center; justify-content:center;
  }
  #wrap {
    width: min(1200px, 96vw);
    height: min(780px, 90vh);
    position: relative;
    box-shadow: 0 12px 40px rgba(0,0,0,.35);
    border-radius: 10px;
    overflow: hidden;
    background:#c69c6d;
  }
  canvas { display:block; width:100%; height:100%; }
  .hint {
    margin-top: 8px; color:#1f2937; background: rgba(255,255,255,.55);
    padding:6px 10px; border-radius:8px; backdrop-filter: blur(3px);
    font-size: 13px;
  }
  .btnbar {
    position:absolute; inset: 10px auto auto 10px; display:flex; gap:8px; z-index:10; flex-wrap:wrap;
  }
  .btn {
    background:#111827; color:white; border:none; border-radius:6px; padding:8px 10px;
    font-weight:700; cursor:pointer; font-size:12px; box-shadow: 0 4px 12px rgba(0,0,0,.25);
  }
  .btn.secondary { background:#334155; }
  .btn:active { transform: translateY(1px); }
</style>
</head>
<body>
  <div id="wrap">
    <div class="btnbar">
      <button class="btn" id="newNote">+ Note</button>
      <button class="btn" id="newTask">+ Task</button>
      <button class="btn secondary" id="toggleStrings">Strings: on</button>
      <button class="btn secondary" id="exportPNG">Export PNG</button>
      <button class="btn secondary" id="save">Save</button>
      <button class="btn secondary" id="reset">Reset</button>
    </div>
    <canvas id="board" width="1200" height="780" aria-label="Quantum Corkboard"></canvas>
  </div>
  <div class="hint">
    Drag notes; doubleâ€‘tap/doubleâ€‘click a note to edit. Tap checkboxes to toggle tasks. Timer: tap to Start/Stop; longâ€‘press/rightâ€‘click to reset. Strings toggle connects notes PKâ€‘style. Pauses when hidden.
  </div>

<script>
// === Utility ===
const TAU = Math.PI * 2;
const canvas = document.getElementById('board');
const ctx = canvas.getContext('2d');
function resizeCanvasToCSS() {
  const rect = canvas.getBoundingClientRect();
  const dpr = window.devicePixelRatio || 1;
  canvas.width = Math.round(rect.width * dpr);
  canvas.height = Math.round(rect.height * dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
new ResizeObserver(resizeCanvasToCSS).observe(canvas);
resizeCanvasToCSS();
const isTouch = 'ontouchstart' in window;

// === Board State ===
const DEFAULT_STATE = {
  date: { title: "November 4", subtitle: "Tuesday 2025" },
  notes: [
    { id: 'sale', x: 70,  y: 120, w: 260, h: 160, color:'#FEF9C3', title:'Sale?', content:'', type:'note' },
    { id: 'fall', x: 870, y: 140, w: 280, h: 160, color:'#FEF9C3', title:'', content:'Fall decorations\nBring down\nfrom attic', type:'note' },
    { id: 'edit', x: 80,  y: 460, w: 300, h: 180, color:'#FEF9C3', title:'', content:'(doubleâ€‘click to edit)', type:'note' },
    { id: 'offer',x: 880, y: 480, w: 280, h: 160, color:'#FEF9C3', title:'Offer\naccepted?', content:'', type:'note' },
  ],
  // center date note
  center: { x: 430, y: 120, w: 340, h: 110 },
  // tasks card
  tasksCard: { x: 430, y: 320, w: 360, h: 280 },
  tasks: [
    { text:'DVDs boxed up to take to Halfâ€‘Price', done:false },
    { text:'Clean kitchen', done:false },
    { text:'Take out trash', done:false },
    { text:'Goal of the week: clear living room to clean carpet', done:false },
  ],
  timer: { seconds: 5*60, running:false, lastTick: performance.now() },
  stringsOn: true,
  draggingId: null,
  dragOffset: {x:0,y:0}
};

const state = load() || DEFAULT_STATE;

// === Persist ===
function save() {
  const copy = JSON.parse(JSON.stringify(state));
  delete copy.timer.lastTick;
  localStorage.setItem('quantumBoardV2', JSON.stringify(copy));
}
function load() {
  try {
    const saved = JSON.parse(localStorage.getItem('quantumBoardV2'));
    return saved;
  } catch { return null; }
}

document.getElementById('save').onclick = save;
document.getElementById('reset').onclick = () => {
  localStorage.removeItem('quantumBoardV2');
  location.reload();
};
document.getElementById('newNote').onclick = () => {
  const id = 'n'+Math.random().toString(36).slice(2,7);
  state.notes.push({ id, x: 140, y: 200, w: 280, h: 160, color:'#FEF9C3', title:'', content:'New note', type:'note' });
  save();
};
document.getElementById('newTask').onclick = () => {
  state.tasks.push({ text:'New taskâ€¦', done:false });
  save();
};
document.getElementById('toggleStrings').onclick = (e) => {
  state.stringsOn = !state.stringsOn;
  e.target.textContent = 'Strings: ' + (state.stringsOn ? 'on' : 'off');
  save();
};
document.getElementById('exportPNG').onclick = () => {
  // upscale for crisp export
  const scale = 2;
  const tmp = document.createElement('canvas');
  tmp.width = canvas.width*scale / (window.devicePixelRatio||1);
  tmp.height= canvas.height*scale / (window.devicePixelRatio||1);
  const tctx = tmp.getContext('2d');
  tctx.setTransform(scale,0,0,scale,0,0);
  render(tctx, tmp.width/scale, tmp.height/scale, true);
  const url = tmp.toDataURL('image/png');
  const a = document.createElement('a');
  a.href = url; a.download = 'quantum_board.png'; a.click();
};

// === Quantum Timer (pauses when not observed) ===
document.addEventListener('visibilitychange', () => {
  if (document.hidden) state.timer.running = false;
});
canvas.addEventListener('contextmenu', e => {
  const p = getMousePos(e);
  if (hitTimer(p.x, p.y)) {
    e.preventDefault();
    state.timer.seconds = 5*60;
    state.timer.running = false;
    save();
  }
});

// === Interaction ===
function getMousePos(evt) {
  const rect = canvas.getBoundingClientRect();
  return { x: (evt.clientX ?? evt.touches?.[0]?.clientX) - rect.left,
           y: (evt.clientY ?? evt.touches?.[0]?.clientY) - rect.top };
}
const downEvt = isTouch ? 'touchstart' : 'mousedown';
const moveEvt = isTouch ? 'touchmove'  : 'mousemove';
const upEvt   = isTouch ? 'touchend'   : 'mouseup';

canvas.addEventListener(downEvt, (e) => {
  const p = getMousePos(e);
  // Timer click?
  if (hitTimer(p.x,p.y)) {
    state.timer.running = !state.timer.running;
    state.timer.lastTick = performance.now();
    save(); return;
  }
  // Tasks
  let taskHit = tasksHitTest(p.x,p.y);
  if (taskHit) {
    if (taskHit.kind === 'box') {
      state.tasks[taskHit.index].done = !state.tasks[taskHit.index].done;
      save(); return;
    } else if (taskHit.kind === 'text') {
      const t = prompt('Edit task:', state.tasks[taskHit.index].text);
      if (t !== null) { state.tasks[taskHit.index].text = t; save(); }
      return;
    } else if (taskHit.kind === 'add') {
      state.tasks.push({text:'New taskâ€¦', done:false}); save(); return;
    }
  }
  // Notes drag
  for (let i = state.notes.length - 1; i >= 0; i--) {
    const n = state.notes[i];
    if (p.x >= n.x && p.x <= n.x + n.w && p.y >= n.y && p.y <= n.y + n.h) {
      state.draggingId = n.id;
      state.dragOffset.x = p.x - n.x;
      state.dragOffset.y = p.y - n.y;
      // bring to front
      state.notes.splice(i,1);
      state.notes.push(n);
      return;
    }
  }
});
canvas.addEventListener(moveEvt, (e) => {
  if (!state.draggingId) return;
  const p = getMousePos(e);
  const n = state.notes.find(n => n.id === state.draggingId);
  if (!n) return;
  n.x = p.x - state.dragOffset.x;
  n.y = p.y - state.dragOffset.y;
});
canvas.addEventListener(upEvt, () => {
  if (state.draggingId) { state.draggingId = null; save(); }
});
canvas.addEventListener('dblclick', (e) => {
  const p = getMousePos(e);
  for (let i = state.notes.length - 1; i >= 0; i--) {
    const n = state.notes[i];
    if (p.x >= n.x && p.x <= n.x + n.w && p.y >= n.y && p.y <= n.y + n.h) {
      const title = prompt('Note title (optional):', n.title || '');
      if (title !== null) n.title = title;
      const content = prompt('Note content:', n.content || '');
      if (content !== null) n.content = content;
      save(); return;
    }
  }
});

// === Hit tests ===
function tasksRect(){ return state.tasksCard; }
function timerRect(){ return { x: canvas.clientWidth - 240, y: 16, w: 220, h: 150 }; }
function hitTimer(x,y){ const r = timerRect(); return x>=r.x && x<=r.x+r.w && y>=r.y && y<=r.y+r.h; }
function tasksHitTest(x,y){
  const r = tasksRect();
  if (!(x>=r.x && x<=r.x+r.w && y>=r.y && y<=r.y+r.h)) return null;
  const padding = 16, lineH = 28, box = 18;
  let yy = r.y + padding + 8;
  for (let i=0;i<state.tasks.length;i++){
    const bx = r.x + padding;
    const by = yy - box + 8;
    if (x>=bx && x<=bx+box && y>=by && y<=by+box) return {kind:'box', index:i};
    if (x>=bx+box+10 && x<=r.x+r.w-padding && y>=yy-20 && y<=yy+6) return {kind:'text', index:i};
    yy += lineH;
  }
  const addY = r.y + r.h - padding - 28;
  const addX = r.x + padding;
  if (x>=addX && x<=addX+90 && y>=addY && y<=addY+24) return {kind:'add'};
  return null;
}

// === Drawing ===
function drawCorkTexture(ctx, W, H){
  ctx.fillStyle = '#c69c6d';
  ctx.fillRect(0,0,W,H);
  // fine speckles
  ctx.globalAlpha = .12;
  const rcount = 900;
  for (let i=0;i<rcount;i++){
    const x = Math.random()*W, y = Math.random()*H;
    const r = Math.random()*1.2;
    ctx.fillStyle = 'rgba(0,0,0,0.8)';
    ctx.beginPath(); ctx.arc(x,y,r,0,TAU); ctx.fill();
  }
  ctx.globalAlpha = 1;
}

function roundedRect(ctx,x,y,w,h,r){
  ctx.beginPath();
  ctx.moveTo(x+r,y);
  ctx.arcTo(x+w,y,x+w,y+h,r);
  ctx.arcTo(x+w,y+h,x,y+h,r);
  ctx.arcTo(x,y+h,x,y,r);
  ctx.arcTo(x,y,x+w,y,r);
  ctx.closePath();
}

function drawPin(ctx,cx,cy){
  ctx.save();
  ctx.shadowColor = 'rgba(0,0,0,.35)'; ctx.shadowBlur = 6; ctx.shadowOffsetY = 2;
  const grd = ctx.createRadialGradient(cx-3, cy-3, 1, cx, cy, 10);
  grd.addColorStop(0, '#d64545'); grd.addColorStop(1, '#a83232');
  ctx.fillStyle = grd;
  ctx.beginPath(); ctx.arc(cx, cy, 10, 0, TAU); ctx.fill();
  ctx.shadowBlur = 0;
  ctx.fillStyle = '#8b2020';
  ctx.fillRect(cx-1, cy+8, 2, 6);
  ctx.restore();
}

function drawNote(ctx, n){
  ctx.save();
  ctx.shadowColor = 'rgba(0,0,0,.25)'; ctx.shadowBlur = 12; ctx.shadowOffsetX = 3; ctx.shadowOffsetY = 6;
  ctx.fillStyle = n.color || '#FEF9C3';
  roundedRect(ctx, n.x, n.y, n.w, n.h, 6); ctx.fill();
  ctx.shadowBlur = 0; ctx.shadowOffsetX = 0; ctx.shadowOffsetY = 0;
  drawPin(ctx, n.x + n.w/2, n.y - 6);
  ctx.fillStyle = '#111';
  ctx.font = '700 20px "Comic Sans MS", system-ui, sans-serif';
  let ty = n.y + 18 + 8;
  if (n.title){
    ctx.fillText(n.title, n.x + 14, ty);
    ty += 26;
  }
  ctx.font = '16px "Comic Sans MS", system-ui, sans-serif';
  const lines = (n.content||'').split(/\n/);
  lines.forEach((ln,i) => ctx.fillText(ln, n.x + 14, ty + i*22));
  ctx.restore();
}

function drawDateCard(ctx){
  const r = state.center;
  ctx.save();
  ctx.shadowColor = 'rgba(0,0,0,.30)'; ctx.shadowBlur = 12; ctx.shadowOffsetY = 3;
  roundedRect(ctx, r.x, r.y, r.w, r.h, 10); ctx.fillStyle = '#2d2d2d'; ctx.fill();
  ctx.shadowBlur = 0;
  ctx.fillStyle = '#fff';
  ctx.font = '700 42px Inter, system-ui, sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText(state.date.title, r.x + r.w/2, r.y + 58);
  ctx.font = '500 18px Inter, system-ui, sans-serif';
  ctx.globalAlpha = .9;
  ctx.fillText(state.date.subtitle, r.x + r.w/2, r.y + 86);
  ctx.globalAlpha = 1;
  ctx.textAlign = 'left';
  ctx.restore();
}

function drawTasks(ctx){
  const r = state.tasksCard;
  ctx.save();
  ctx.shadowColor = 'rgba(0,0,0,.25)'; ctx.shadowBlur = 12; ctx.shadowOffsetY = 3;
  roundedRect(ctx, r.x, r.y, r.w, r.h, 6); ctx.fillStyle = '#e8dcc4'; ctx.fill();
  ctx.shadowBlur = 0;
  const padding = 16; const lineH = 28; const box = 18;
  let y = r.y + padding + 8;
  ctx.font = '15px Arial, sans-serif'; ctx.fillStyle = '#111';
  state.tasks.forEach((t,i) => {
    // checkbox
    ctx.lineWidth = 2; ctx.strokeStyle = '#333'; ctx.strokeRect(r.x + padding, y - box + 8, box, box);
    if (t.done){
      ctx.fillStyle = '#4ade80'; ctx.fillRect(r.x + padding, y - box + 8, box, box);
      ctx.fillStyle = '#fff'; ctx.font = 'bold 14px Arial'; ctx.fillText('âœ“', r.x + padding + 4, y + 2);
      ctx.font = '15px Arial'; ctx.fillStyle = '#333'; ctx.globalAlpha = .65;
      ctx.fillText(t.text, r.x + padding + box + 10, y);
      ctx.globalAlpha = 1;
    } else {
      ctx.fillStyle = '#111'; ctx.fillText(t.text, r.x + padding + box + 10, y);
    }
    y += lineH;
  });
  // add task button
  const addY = r.y + r.h - padding - 8;
  ctx.fillStyle = '#4ade80';
  roundedRect(ctx, r.x + padding, addY - 20, 100, 26, 4); ctx.fill();
  ctx.fillStyle = '#fff'; ctx.font = 'bold 14px Arial';
  ctx.fillText('+ Add Task', r.x + padding + 12, addY - 2);
  ctx.restore();
}

function drawTimer(ctx){
  const r = timerRect();
  ctx.save();
  ctx.shadowColor = 'rgba(0,0,0,.25)'; ctx.shadowBlur = 10; ctx.shadowOffsetY = 2;
  roundedRect(ctx, r.x, r.y, r.w, r.h, 10); ctx.fillStyle = '#ffffff'; ctx.fill();
  ctx.shadowBlur = 0;
  ctx.fillStyle = '#64748b'; ctx.font = '12px Inter, sans-serif';
  ctx.fillText('Quantum Timer', r.x + 12, r.y + 18);
  const m = Math.floor(state.timer.seconds / 60);
  const s = Math.floor(state.timer.seconds % 60);
  ctx.fillStyle = '#111827'; ctx.font = 'bold 28px "Courier New", ui-monospace';
  ctx.fillText(String(m).padStart(2,'0') + ':' + String(s).padStart(2,'0'), r.x + 12, r.y + 52);
  ctx.font = '12px Inter, sans-serif'; ctx.fillStyle = '#6b7280';
  ctx.fillText(state.timer.running ? 'Observed' : 'Unobserved (paused)', r.x + 12, r.y + 70);
  // buttons
  ctx.fillStyle = state.timer.running ? '#f87171' : '#4ade80';
  roundedRect(ctx, r.x + 12, r.y + 84, 80, 28, 6); ctx.fill();
  ctx.fillStyle = '#fff'; ctx.font = 'bold 12px Inter';
  ctx.fillText(state.timer.running ? 'Stop' : 'Start', r.x + 12 + 22, r.y + 102);
  ctx.fillStyle = '#94a3b8';
  roundedRect(ctx, r.x + 100, r.y + 84, 80, 28, 6); ctx.fill();
  ctx.fillStyle = '#fff';
  ctx.fillText('Reset', r.x + 100 + 26, r.y + 102);
  // Disclaimer
  ctx.fillStyle = '#475569'; ctx.font = '11px Inter, sans-serif';
  const lines = [
    'Disclaimer: advances only while visible.',
    'If reality desynchronizes (hidden), it pauses.'
  ];
  lines.forEach((ln,i)=> ctx.fillText(ln, r.x + 12, r.y + 122 + i*14));
  ctx.restore();
}

function drawFooter(ctx, W, H){
  ctx.save();
  ctx.fillStyle = 'rgba(255,255,255,.6)';
  roundedRect(ctx, 24, H - 40, 360, 26, 6); ctx.fill();
  ctx.fillStyle = '#1f2937'; ctx.font = '13px Inter, sans-serif';
  ctx.fillText('Reality status: subject to revision. Keep your receipts ðŸ§·', 34, H - 23);
  ctx.restore();
}

// Red string connections
function drawStrings(ctx){
  if (!state.stringsOn) return;
  ctx.save();
  ctx.strokeStyle = '#b42323'; ctx.lineWidth = 3; ctx.lineCap = 'round';
  // connect each corner note to center date card
  const r = state.center;
  const cx = r.x + r.w/2, cy = r.y + r.h/2;
  for (const n of state.notes){
    const nx = n.x + n.w/2, ny = n.y + 10; // from pin
    ctx.beginPath();
    ctx.moveTo(nx, ny);
    // slight curve
    const mx = (nx + cx)/2, my = (ny + cy)/2 - 30;
    ctx.quadraticCurveTo(mx, my, cx, cy);
    ctx.stroke();
  }
  ctx.restore();
}

// === Main render (also used for export) ===
function render(rc, W, H, exporting=false){
  // background cork
  drawCorkTexture(rc, W, H);
  // center date
  drawDateCard(rc);
  // notes + tasks + strings
  drawStrings(rc);
  for (const n of state.notes) drawNote(rc, n);
  drawTasks(rc);
  drawTimer(rc);
  drawFooter(rc, W, H);
}

// === Loop ===
let lastRAF = performance.now();
function tick(t){
  const dt = (t - lastRAF)/1000; lastRAF = t;
  if (state.timer.running && !document.hidden){
    state.timer.lastTick = t;
    state.timer.seconds = Math.max(0, state.timer.seconds - dt);
    if (state.timer.seconds <= 0) state.timer.running = false;
  }
  ctx.clearRect(0,0,canvas.clientWidth, canvas.clientHeight);
  render(ctx, canvas.clientWidth, canvas.clientHeight);
  requestAnimationFrame(tick);
}
requestAnimationFrame(tick);
</script>
</body>
</html>
