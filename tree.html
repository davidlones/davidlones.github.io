<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>XP Desktop Tree â€“ Physics Lights</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        height: 100%;
        width: 100%;
        background: radial-gradient(circle at top, #1a2340 0%, #050713 60%, #000 100%);
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
          sans-serif;
      }
      #root {
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      /* Simple context menu */
      .tree-context-menu {
        position: fixed;
        z-index: 9999;
        background: rgba(10, 14, 30, 0.97);
        border-radius: 8px;
        border: 1px solid rgba(255, 255, 255, 0.12);
        box-shadow: 0 16px 40px rgba(0, 0, 0, 0.6);
        padding: 6px 0;
        min-width: 160px;
        backdrop-filter: blur(10px);
      }
      .tree-context-menu button {
        display: block;
        width: 100%;
        padding: 6px 12px;
        border: none;
        background: transparent;
        text-align: left;
        font-size: 12px;
        color: #d3ddff;
        cursor: pointer;
      }
      .tree-context-menu button:hover {
        background: rgba(120, 150, 255, 0.15);
      }
    </style>

    <!-- React / ReactDOM / Babel -->
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  </head>
  <body>
    <div id="root"></div>

    <script type="text/babel">
      const { useRef, useEffect, useState } = React;

      function ChristmasTreeCanvas({ width = 340, height = 440 }) {
        const canvasRef = useRef(null);

        // --- Shared refs so events + animation share state ---
        const starsRef = useRef([]);
        const snowflakesRef = useRef([]);

        const lightsRef = useRef([]);       // lights with physics
        const decorationsRef = useRef([]);  // ornaments
        const presentsRef = useRef([]);     // presents

        const draggingLightRef = useRef(null);
        const lastTimeRef = useRef(null);

        // context menu state (React UI)
        const [menuState, setMenuState] = useState(null);
        // for long-press on touch
        const longPressTimeoutRef = useRef(null);

        useEffect(() => {
          const canvas = canvasRef.current;
          const ctx = canvas.getContext("2d");

          const dpr = window.devicePixelRatio || 1;
          canvas.width = width * dpr;
          canvas.height = height * dpr;
          canvas.style.width = width + "px";
          canvas.style.height = height + "px";
          ctx.scale(dpr, dpr);

          let animationFrameId;
          const maxSnowflakes = 120;
          const numStars = 45;

          function createStars() {
            const stars = [];
            for (let i = 0; i < numStars; i++) {
              stars.push({
                x: Math.random() * width,
                y: Math.random() * height * 0.45,
                r: Math.random() * 0.9 + 0.2,
                alpha: 0.4 + Math.random() * 0.4,
              });
            }
            starsRef.current = stars;
          }

          function createSnowflakes() {
            const snow = [];
            for (let i = 0; i < maxSnowflakes; i++) {
              snow.push({
                x: Math.random() * width,
                y: Math.random() * height,
                r: 1 + Math.random() * 2.5,
                vy: 0.4 + Math.random() * 0.9,
                drift: (Math.random() - 0.5) * 0.35,
              });
            }
            snowflakesRef.current = snow;
          }

          // --- Lights with simple string physics ---
          function createTreeLights() {
            const lights = [];
            const layers = 5;
            const baseWidth = width * 0.7;
            const topY = height * 0.26;
            const baseY = height * 0.62;
            const centerX = width / 2;

            let index = 0;

            for (let i = 0; i < layers; i++) {
              const t = i / (layers - 1); // 0 bottom, 1 top
              const y = baseY - t * (baseY - topY);
              const w = baseWidth * (1 - t * 0.75); // widest at bottom

              const count = 10 + i * 3;
              let previousIndex = null;

              for (let j = 0; j < count; j++) {
                const ratio = j / (count - 1 || 1);
                const x = centerX - w / 2 + ratio * w;
                const light = {
                  x: x + (Math.random() - 0.5) * 5,
                  y: y + (Math.random() - 0.5) * 4,
                  vx: 0,
                  vy: 0,
                  phase: Math.random() * Math.PI * 2,
                  hue: 20 + Math.random() * 300,
                  radius: 2,
                  stringId: i,
                  neighbors: [],
                  isDragged: false,
                };

                // connect to previous light in this row (string physics)
                if (previousIndex !== null) {
                  light.neighbors.push(previousIndex);
                  lights[previousIndex].neighbors.push(index);
                }
                previousIndex = index;

                lights.push(light);
                index++;
              }
            }

            lightsRef.current = lights;
          }

          function addLightAt(x, y) {
            const lights = lightsRef.current.slice();
            const newIndex = lights.length;

            const light = {
              x,
              y,
              vx: 0,
              vy: 0,
              phase: Math.random() * Math.PI * 2,
              hue: 20 + Math.random() * 300,
              radius: 2,
              stringId: -1, // freestyle
              neighbors: [],
              isDragged: false,
            };

            // Optionally connect to nearest existing light
            if (lights.length > 0) {
              let nearest = 0;
              let bestDist = Infinity;
              for (let i = 0; i < lights.length; i++) {
                const dx = lights[i].x - x;
                const dy = lights[i].y - y;
                const d2 = dx * dx + dy * dy;
                if (d2 < bestDist) {
                  bestDist = d2;
                  nearest = i;
                }
              }
              light.neighbors.push(nearest);
              lights[nearest].neighbors.push(newIndex);
            }

            lights.push(light);
            lightsRef.current = lights;
          }

          function addDecorationAt(x, y) {
            const decorations = decorationsRef.current.slice();
            decorations.push({
              x,
              y,
              r: 5 + Math.random() * 4,
              hue: 180 + Math.random() * 120,
            });
            decorationsRef.current = decorations;
          }

          function addPresentAt(x, y) {
            const presents = presentsRef.current.slice();
            const boxWidth = 26 + Math.random() * 12;
            const boxHeight = 16 + Math.random() * 8;

            // Snap closer to bottom snow if user clicks higher
            const snowLineY = height * 0.82;
            const py = Math.max(y, snowLineY - boxHeight / 2);

            presents.push({
              x,
              y: py,
              w: boxWidth,
              h: boxHeight,
              hue: Math.random() * 360,
            });
            presentsRef.current = presents;
          }

          createStars();
          createTreeLights();
          createSnowflakes();

          function drawBackground(time) {
            const stars = starsRef.current;

            const g = ctx.createLinearGradient(0, 0, 0, height);
            g.addColorStop(0, "#050716");
            g.addColorStop(0.5, "#050816");
            g.addColorStop(1, "#03040a");
            ctx.fillStyle = g;
            ctx.fillRect(0, 0, width, height);

            const radius = Math.max(width, height);
            const vg = ctx.createRadialGradient(
              width / 2,
              height * 0.18,
              radius * 0.1,
              width / 2,
              height / 2,
              radius * 0.9
            );
            vg.addColorStop(0, "rgba(80,100,200,0.12)");
            vg.addColorStop(1, "rgba(0,0,0,0.95)");
            ctx.fillStyle = vg;
            ctx.fillRect(0, 0, width, height);

            stars.forEach((s, idx) => {
              const twinkle = 0.2 * Math.sin(time * 0.8 + idx * 1.7);
              ctx.fillStyle = `rgba(255,255,255,${s.alpha + twinkle})`;
              ctx.beginPath();
              ctx.arc(s.x, s.y, s.r, 0, Math.PI * 2);
              ctx.fill();
            });
          }

          function drawSnow() {
            const snowflakes = snowflakesRef.current;
            ctx.save();
            ctx.globalAlpha = 0.9;
            ctx.fillStyle = "#ffffff";
            snowflakes.forEach((fl) => {
              ctx.beginPath();
              ctx.arc(fl.x, fl.y, fl.r, 0, Math.PI * 2);
              ctx.fill();
            });
            ctx.restore();
          }

          function updateSnow() {
            const snowflakes = snowflakesRef.current;
            for (const fl of snowflakes) {
              fl.y += fl.vy;
              fl.x += fl.drift;

              if (fl.y > height + 5) {
                fl.y = -5;
                fl.x = Math.random() * width;
              }
              if (fl.x < -5) fl.x = width + 5;
              if (fl.x > width + 5) fl.x = -5;
            }
          }

          function drawTree() {
            const centerX = width / 2;
            const topY = height * 0.26;
            const baseY = height * 0.62;
            const baseWidth = width * 0.7;
            const layers = 5;

            const glow = ctx.createRadialGradient(
              centerX,
              baseY * 0.98,
              width * 0.08,
              centerX,
              baseY,
              width * 0.8
            );
            glow.addColorStop(0, "rgba(40,255,160,0.22)");
            glow.addColorStop(1, "rgba(0,0,0,0)");
            ctx.fillStyle = glow;
            ctx.fillRect(0, 0, width, height);

            for (let i = 0; i < layers; i++) {
              const t = i / (layers - 1);
              const y = baseY - t * (baseY - topY);
              const w = baseWidth * (1 - t * 0.75);

              const grad = ctx.createLinearGradient(
                centerX,
                y - 28,
                centerX,
                y + 32
              );
              grad.addColorStop(0, "#1d8b4e");
              grad.addColorStop(0.5, "#0f5c33");
              grad.addColorStop(1, "#072618");

              ctx.fillStyle = grad;
              ctx.beginPath();
              ctx.moveTo(centerX, y - 28);
              ctx.lineTo(centerX - w / 2, y + 32);
              ctx.lineTo(centerX + w / 2, y + 32);
              ctx.closePath();
              ctx.fill();

              ctx.strokeStyle = "rgba(190,255,220,0.14)";
              ctx.lineWidth = 1;
              ctx.stroke();
            }

            const trunkWidth = baseWidth * 0.18;
            const trunkHeight = height * 0.1;
            const trunkX = centerX - trunkWidth / 2;
            const trunkY = baseY + 24;
            const trunkGrad = ctx.createLinearGradient(
              trunkX,
              trunkY,
              trunkX + trunkWidth,
              trunkY + trunkHeight
            );
            trunkGrad.addColorStop(0, "#5a3a22");
            trunkGrad.addColorStop(1, "#2b1d12");

            ctx.fillStyle = trunkGrad;
            ctx.fillRect(trunkX, trunkY, trunkWidth, trunkHeight);

            ctx.fillStyle = "#f5f7ff";
            ctx.beginPath();
            ctx.moveTo(-10, height * 0.82);
            ctx.quadraticCurveTo(
              width * 0.28,
              height * 0.76,
              width * 0.55,
              height * 0.83
            );
            ctx.quadraticCurveTo(
              width * 0.82,
              height * 0.9,
              width + 10,
              height * 0.86
            );
            ctx.lineTo(width + 10, height + 10);
            ctx.lineTo(-10, height + 10);
            ctx.closePath();
            ctx.fill();
          }

          function drawStar(time) {
            const centerX = width / 2;
            const topY = height * 0.26;
            const baseRadius = 10;
            const pulse = 1 + Math.sin(time * 2.2) * 0.22;
            const r = baseRadius * pulse;

            ctx.save();
            ctx.translate(centerX, topY - 34);
            ctx.rotate(Math.sin(time * 0.7) * 0.05);

            const glowGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, r * 3.3);
            glowGrad.addColorStop(0, "rgba(255,255,200,0.95)");
            glowGrad.addColorStop(0.4, "rgba(255,230,150,0.55)");
            glowGrad.addColorStop(1, "rgba(0,0,0,0)");
            ctx.fillStyle = glowGrad;
            ctx.beginPath();
            ctx.arc(0, 0, r * 3.3, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = "#fff7c2";
            ctx.beginPath();
            const spikes = 5;
            const outerRadius = r;
            const innerRadius = r * 0.45;
            for (let i = 0; i < spikes * 2; i++) {
              const angle = (i * Math.PI) / spikes;
              const radius = i % 2 === 0 ? outerRadius : innerRadius;
              ctx.lineTo(Math.cos(angle) * radius, Math.sin(angle) * radius);
            }
            ctx.closePath();
            ctx.fill();

            ctx.restore();
          }

          function drawLights(time) {
            const lights = lightsRef.current;
            lights.forEach((l) => {
              const t = time * 3 + l.phase;
              const baseAlpha = 0.35 + 0.4 * (0.5 + 0.5 * Math.sin(t));
              const outerAlpha = baseAlpha * 0.7;

              const radius = 6;
              const grad = ctx.createRadialGradient(
                l.x,
                l.y,
                0,
                l.x,
                l.y,
                radius
              );
              grad.addColorStop(0, `hsla(${l.hue}, 90%, 70%, ${outerAlpha})`);
              grad.addColorStop(1, "rgba(0,0,0,0)");
              ctx.fillStyle = grad;
              ctx.beginPath();
              ctx.arc(l.x, l.y, radius, 0, Math.PI * 2);
              ctx.fill();

              ctx.fillStyle = `hsla(${l.hue}, 100%, 75%, 0.96)`;
              ctx.beginPath();
              ctx.arc(l.x, l.y, l.radius, 0, Math.PI * 2);
              ctx.fill();
            });

            // optionally draw faint "wires" between neighbors
            ctx.save();
            ctx.strokeStyle = "rgba(40, 80, 40, 0.45)";
            ctx.lineWidth = 0.7;
            lights.forEach((l, idx) => {
              l.neighbors.forEach((nIdx) => {
                if (nIdx > idx) {
                  const n = lights[nIdx];
                  ctx.beginPath();
                  ctx.moveTo(l.x, l.y);
                  ctx.lineTo(n.x, n.y);
                  ctx.stroke();
                }
              });
            });
            ctx.restore();
          }

          function drawDecorations() {
            const decorations = decorationsRef.current;
            decorations.forEach((d) => {
              const g = ctx.createRadialGradient(d.x, d.y, 0, d.x, d.y, d.r * 1.8);
              g.addColorStop(0, `hsla(${d.hue}, 95%, 80%, 0.95)`);
              g.addColorStop(1, "rgba(0,0,0,0)");
              ctx.fillStyle = g;
              ctx.beginPath();
              ctx.arc(d.x, d.y, d.r * 1.8, 0, Math.PI * 2);
              ctx.fill();

              ctx.fillStyle = `hsla(${d.hue}, 90%, 65%, 0.98)`;
              ctx.beginPath();
              ctx.arc(d.x, d.y, d.r, 0, Math.PI * 2);
              ctx.fill();

              // tiny highlight
              ctx.fillStyle = "rgba(255,255,255,0.85)";
              ctx.beginPath();
              ctx.arc(d.x - d.r * 0.3, d.y - d.r * 0.3, d.r * 0.35, 0, Math.PI * 2);
              ctx.fill();
            });
          }

          function drawPresents() {
            const presents = presentsRef.current;
            const centerX = width / 2;
            const baseY = height * 0.62;
            const snowLineY = height * 0.82;

            presents.forEach((p) => {
              const y = Math.max(p.y, snowLineY - p.h / 2);

              const g = ctx.createLinearGradient(
                p.x - p.w / 2,
                y - p.h / 2,
                p.x + p.w / 2,
                y + p.h / 2
              );
              g.addColorStop(0, `hsla(${p.hue}, 70%, 45%, 1)`);
              g.addColorStop(1, `hsla(${p.hue + 30}, 70%, 30%, 1)`);
              ctx.fillStyle = g;
              ctx.fillRect(p.x - p.w / 2, y - p.h / 2, p.w, p.h);

              // ribbon vertical
              ctx.fillStyle = "rgba(255,255,255,0.85)";
              const ribbonW = p.w * 0.16;
              ctx.fillRect(
                p.x - ribbonW / 2,
                y - p.h / 2,
                ribbonW,
                p.h
              );
              // ribbon horizontal
              const ribbonH = p.h * 0.16;
              ctx.fillRect(
                p.x - p.w / 2,
                y - ribbonH / 2,
                p.w,
                ribbonH
              );
            });
          }

          // --- Simple string physics for lights ---
          function stepLightsPhysics(dt) {
            const lights = lightsRef.current;
            if (!lights.length) return;

            const gravity = 500; // px/s^2
            const damping = 0.92;
            const springK = 40; // stiffness
            const restLength = 10; // target distance between neighbors

            // Apply forces
            for (let i = 0; i < lights.length; i++) {
              const l = lights[i];
              if (l.isDragged) {
                l.vx = 0;
                l.vy = 0;
                continue;
              }

              // gravity
              l.vy += gravity * dt;

              // springs to neighbors
              l.neighbors.forEach((nIdx) => {
                const n = lights[nIdx];
                const dx = n.x - l.x;
                const dy = n.y - l.y;
                const dist = Math.sqrt(dx * dx + dy * dy) || 0.0001;
                const diff = dist - restLength;
                const force = (springK * diff) / dist;

                const fx = force * dx;
                const fy = force * dy;

                l.vx += fx * dt;
                l.vy += fy * dt;

                // equal and opposite on neighbor
                if (!n.isDragged) {
                  n.vx -= fx * dt;
                  n.vy -= fy * dt;
                }
              });
            }

            // Integrate
            for (let i = 0; i < lights.length; i++) {
              const l = lights[i];
              if (l.isDragged) continue;

              l.vx *= damping;
              l.vy *= damping;

              l.x += l.vx * dt;
              l.y += l.vy * dt;

              // keep within canvas loosely
              if (l.x < 0) {
                l.x = 0;
                l.vx *= -0.4;
              }
              if (l.x > width) {
                l.x = width;
                l.vx *= -0.4;
              }
              if (l.y < 0) {
                l.y = 0;
                l.vy *= -0.4;
              }
              if (l.y > height) {
                l.y = height;
                l.vy *= -0.4;
              }
            }
          }

          function render(timestamp) {
            const time = timestamp / 1000;
            const last = lastTimeRef.current ?? time;
            const dt = Math.min(time - last, 0.05); // clamp delta
            lastTimeRef.current = time;

            ctx.clearRect(0, 0, width, height);

            stepLightsPhysics(dt);

            drawBackground(time);
            drawSnow();
            drawTree();
            drawPresents();
            drawDecorations();
            drawLights(time);
            drawStar(time);
            updateSnow();

            animationFrameId = requestAnimationFrame(render);
          }

          animationFrameId = requestAnimationFrame(render);

          function handleResize() {
            const rect = canvas.getBoundingClientRect();
            const dprNew = window.devicePixelRatio || 1;
            canvas.width = rect.width * dprNew;
            canvas.height = rect.height * dprNew;
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.scale(dprNew, dprNew);
            createStars();
            createTreeLights();
            createSnowflakes();
          }

          window.addEventListener("resize", handleResize);

          // --- Pointer interaction for dragging & menu ---

          function getCanvasCoords(evt) {
            const rect = canvas.getBoundingClientRect();
            const x = ((evt.clientX - rect.left) / rect.width) * width;
            const y = ((evt.clientY - rect.top) / rect.height) * height;
            return { x, y };
          }

          function findLightAt(x, y, radius = 12) {
            const lights = lightsRef.current;
            let foundIndex = null;
            let best = radius * radius;
            for (let i = 0; i < lights.length; i++) {
              const l = lights[i];
              const dx = l.x - x;
              const dy = l.y - y;
              const d2 = dx * dx + dy * dy;
              if (d2 <= best) {
                best = d2;
                foundIndex = i;
              }
            }
            return foundIndex;
          }

          function pointerDown(evt) {
            // left click / touch: drag
            if (evt.button === 0 || evt.pointerType === "touch") {
              const { x, y } = getCanvasCoords(evt);
              const idx = findLightAt(x, y);
              if (idx !== null) {
                draggingLightRef.current = idx;
                const lights = lightsRef.current;
                lights[idx].isDragged = true;
              }

              // schedule long-press for context menu (touch)
              if (evt.pointerType === "touch") {
                const clientX = evt.clientX;
                const clientY = evt.clientY;
                longPressTimeoutRef.current = setTimeout(() => {
                  setMenuState({
                    x: clientX,
                    y: clientY,
                    canvasX: x,
                    canvasY: y,
                  });
                }, 600);
              }
            }
          }

          function pointerMove(evt) {
            const idx = draggingLightRef.current;
            if (idx !== null) {
              evt.preventDefault();
              const { x, y } = getCanvasCoords(evt);
              const lights = lightsRef.current;
              const l = lights[idx];
              l.x = x;
              l.y = y;
              l.vx = 0;
              l.vy = 0;
            }
          }

          function pointerUp(evt) {
            if (longPressTimeoutRef.current) {
              clearTimeout(longPressTimeoutRef.current);
              longPressTimeoutRef.current = null;
            }
            const idx = draggingLightRef.current;
            if (idx !== null) {
              const lights = lightsRef.current;
              lights[idx].isDragged = false;
            }
            draggingLightRef.current = null;
          }

          function pointerCancel(evt) {
            pointerUp(evt);
          }

          function contextMenu(evt) {
            evt.preventDefault();
            const { x, y } = getCanvasCoords(evt);
            setMenuState({
              x: evt.clientX,
              y: evt.clientY,
              canvasX: x,
              canvasY: y,
            });
          }

          canvas.addEventListener("pointerdown", pointerDown);
          canvas.addEventListener("pointermove", pointerMove);
          canvas.addEventListener("pointerup", pointerUp);
          canvas.addEventListener("pointercancel", pointerCancel);
          canvas.addEventListener("contextmenu", contextMenu);

          return () => {
            cancelAnimationFrame(animationFrameId);
            window.removeEventListener("resize", handleResize);

            canvas.removeEventListener("pointerdown", pointerDown);
            canvas.removeEventListener("pointermove", pointerMove);
            canvas.removeEventListener("pointerup", pointerUp);
            canvas.removeEventListener("pointercancel", pointerCancel);
            canvas.removeEventListener("contextmenu", contextMenu);
          };
        }, [width, height]);

        // context menu actions (run on main thread, mutate refs)
        const handleMenuAction = (action) => {
          if (!menuState) return;
          const { canvasX, canvasY } = menuState;

          if (action === "add-light") {
            // use effect's helper shape: re-implement minimal here:
            const lights = lightsRef.current.slice();
            const x = canvasX;
            const y = canvasY;
            const newIndex = lights.length;
            const light = {
              x,
              y,
              vx: 0,
              vy: 0,
              phase: Math.random() * Math.PI * 2,
              hue: 20 + Math.random() * 300,
              radius: 2,
              stringId: -1,
              neighbors: [],
              isDragged: false,
            };
            if (lights.length > 0) {
              let nearest = 0;
              let bestDist = Infinity;
              for (let i = 0; i < lights.length; i++) {
                const dx = lights[i].x - x;
                const dy = lights[i].y - y;
                const d2 = dx * dx + dy * dy;
                if (d2 < bestDist) {
                  bestDist = d2;
                  nearest = i;
                }
              }
              light.neighbors.push(nearest);
              lights[nearest].neighbors.push(newIndex);
            }
            lights.push(light);
            lightsRef.current = lights;
          } else if (action === "add-ornament") {
            const decorations = decorationsRef.current.slice();
            decorations.push({
              x: canvasX,
              y: canvasY,
              r: 5 + Math.random() * 4,
              hue: 180 + Math.random() * 120,
            });
            decorationsRef.current = decorations;
          } else if (action === "add-present") {
            const presents = presentsRef.current.slice();
            const snowLineY = height * 0.82;
            const boxWidth = 26 + Math.random() * 12;
            const boxHeight = 16 + Math.random() * 8;
            const py = Math.max(canvasY, snowLineY - boxHeight / 2);
            presents.push({
              x: canvasX,
              y: py,
              w: boxWidth,
              h: boxHeight,
              hue: Math.random() * 360,
            });
            presentsRef.current = presents;
          }

          setMenuState(null);
        };

        const handleGlobalClick = () => {
          if (menuState) setMenuState(null);
        };

        const wrapperStyle = {
          borderRadius: "12px",
          overflow: "hidden",
          border: "1px solid rgba(255,255,255,0.1)",
          backgroundColor: "black",
          position: "relative",
        };

        return (
          <div style={wrapperStyle} onClick={handleGlobalClick}>
            <canvas ref={canvasRef} />
            {menuState && (
              <div
                className="tree-context-menu"
                style={{ left: menuState.x, top: menuState.y }}
              >
                <button onClick={() => handleMenuAction("add-light")}>
                  Add light here
                </button>
                <button onClick={() => handleMenuAction("add-ornament")}>
                  Add ornament
                </button>
                <button onClick={() => handleMenuAction("add-present")}>
                  Add present under tree
                </button>
              </div>
            )}
          </div>
        );
      }

      function App() {
        const appStyle = {
          margin: 0,
          padding: 0,
          width: "100vw",
          height: "100vh",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          color: "#eee",
        };

        const cardStyle = {
          boxShadow: "0 24px 60px rgba(0,0,0,0.65)",
          borderRadius: "16px",
          padding: "16px 18px 12px",
          background:
            "linear-gradient(145deg, rgba(8,12,25,0.96), rgba(20,30,60,0.98))",
          border: "1px solid rgba(255,255,255,0.08)",
          backdropFilter: "blur(12px)",
        };

        const titleStyle = {
          fontSize: "14px",
          letterSpacing: "0.12em",
          textTransform: "uppercase",
          color: "#9fb3ff",
          marginBottom: "8px",
        };

        const subtitleStyle = {
          fontSize: "12px",
          color: "#b7c0e8",
          opacity: 0.8,
          marginBottom: "10px",
        };

        return (
          <div style={appStyle}>
            <div style={cardStyle}>
              <div style={titleStyle}>Desktop Tree</div>
              <div style={subtitleStyle}>
                XP spirit, 2025 renderer. Now with wiggly physics.
              </div>
              <ChristmasTreeCanvas />
            </div>
          </div>
        );
      }

      const rootEl = document.getElementById("root");
      const root = ReactDOM.createRoot(rootEl);
      root.render(<App />);
    </script>
  </body>
</html>