<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Worker Value & System Ownership — Interactive Map</title>
  <style>
    :root{
      --bg:#0b0f14;
      --panel:#101826;
      --panel2:#0e1522;
      --text:#e9eef6;
      --muted:#a9b6c7;
      --line:rgba(233,238,246,.12);
      --accent:#7cd4ff;
      --accent2:#b5ff7c;
      --warn:#ffcc66;
      --bad:#ff7c9c;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      --shadow: 0 18px 60px rgba(0,0,0,.55);
      --radius: 18px;
      --maxw: 1180px;
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; margin:0; }
    body{
      font-family: var(--sans);
      background:
        radial-gradient(1200px 800px at 20% 10%, rgba(124,212,255,.12), transparent 60%),
        radial-gradient(1000px 700px at 90% 20%, rgba(181,255,124,.08), transparent 55%),
        radial-gradient(1000px 700px at 60% 95%, rgba(255,204,102,.06), transparent 55%),
        var(--bg);
      color: var(--text);
      overflow:hidden;
    }

    /* App shell */
    .app{
      height:100%;
      display:grid;
      grid-template-rows: auto 1fr auto;
    }

    header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding: 14px 18px;
      border-bottom: 1px solid var(--line);
      background: rgba(16,24,38,.72);
      backdrop-filter: blur(10px);
      gap: 10px;
    }

    .brand{
      display:flex;
      flex-direction:column;
      min-width: 0;
      gap: 2px;
    }
    .brand h1{
      margin:0;
      font-size: 14px;
      letter-spacing:.2px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      max-width: 70vw;
    }
    .brand .sub{
      margin:0;
      font-size: 12px;
      color: var(--muted);
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      max-width: 70vw;
    }

    .controls{
      display:flex;
      align-items:center;
      gap: 8px;
      flex-wrap: wrap;
      justify-content:flex-end;
    }

    button, .pill, select{
      border: 1px solid var(--line);
      background: rgba(14,21,34,.65);
      color: var(--text);
      border-radius: 999px;
      padding: 8px 12px;
      font-size: 12px;
      cursor:pointer;
      user-select:none;
      transition: transform .06s ease, border-color .12s ease, background .12s ease;
    }
    button:hover, select:hover{ border-color: rgba(124,212,255,.35); }
    button:active{ transform: translateY(1px); }
    select{ cursor:pointer; }
    .pill{
      cursor:default;
      color: var(--muted);
      display:flex;
      align-items:center;
      gap: 8px;
    }
    .pill kbd{
      font-family: var(--mono);
      font-size: 11px;
      padding: 2px 6px;
      border: 1px solid var(--line);
      border-bottom-color: rgba(233,238,246,.22);
      border-radius: 8px;
      color: var(--text);
      background: rgba(0,0,0,.15);
    }

    /* Main layout: Map/Deck + Details panel */
    main{
      display:flex;
      justify-content:center;
      padding: 16px 18px;
      overflow:hidden;
    }
    .stage{
      width: min(var(--maxw), calc(100vw - 36px));
      height: 100%;
      display:grid;
      grid-template-columns: 1.6fr .9fr;
      gap: 14px;
      min-height: 0;
    }

    @media (max-width: 980px){
      .stage{ grid-template-columns: 1fr; }
      body{ overflow:auto; }
      main{ overflow: visible; }
    }

    .panel{
      border-radius: var(--radius);
      border: 1px solid var(--line);
      background: linear-gradient(180deg, rgba(16,24,38,.86), rgba(14,21,34,.86));
      box-shadow: var(--shadow);
      min-height: 0;
      overflow:hidden;
    }

    /* Left panel contains two modes */
    .left{
      display:flex;
      flex-direction:column;
      min-height: 0;
    }
    .leftTopbar{
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding: 10px 12px;
      border-bottom: 1px solid var(--line);
      gap: 10px;
    }
    .modeTabs{
      display:flex;
      gap: 8px;
      align-items:center;
    }
    .tab{
      padding: 8px 12px;
      border-radius: 999px;
      border: 1px solid var(--line);
      background: rgba(0,0,0,.10);
      color: rgba(233,238,246,.86);
      cursor:pointer;
      font-size: 12px;
    }
    .tab.active{
      border-color: rgba(124,212,255,.45);
      background: rgba(124,212,255,.10);
      color: var(--text);
    }
    .miniControls{
      display:flex;
      gap: 8px;
      align-items:center;
      flex-wrap:wrap;
      justify-content:flex-end;
    }

    .viewport{
      position:relative;
      flex: 1;
      min-height: 0;
      overflow:auto;
      padding: 12px;
    }

    /* Map */
    .mapWrap{
      display:none;
      height: 100%;
      min-height: 560px;
    }
    .mapWrap.active{ display:block; }

    .mapLegend{
      display:flex;
      gap: 10px;
      flex-wrap:wrap;
      margin: 0 0 10px;
      color: var(--muted);
      font-size: 12px;
      align-items:center;
    }
    .dot{
      display:inline-block;
      width: 10px; height: 10px;
      border-radius: 50%;
      margin-right: 6px;
      vertical-align: -1px;
      border: 1px solid rgba(233,238,246,.22);
    }
    .dot.actual{ background: rgba(124,212,255,.30); }
    .dot.alt{ background: rgba(255,204,102,.30); }
    .dot.analogy{ background: rgba(181,255,124,.26); }

    svg{ max-width: 100%; height: auto; display:block; }

    .node rect, .node polygon{
      fill: rgba(124,212,255,.08);
      stroke: rgba(124,212,255,.6);
      stroke-width: 1.4;
      cursor: pointer;
    }
    .node.decision polygon{
      stroke: rgba(255,204,102,.8);
      fill: rgba(255,204,102,.10);
    }
    .node.alt rect{
      stroke: rgba(255,204,102,.8);
      fill: rgba(255,204,102,.08);
      stroke-dasharray: 5 4;
    }
    .node text{
      fill: rgba(233,238,246,.92);
      font-size: 13px;
      user-select:none;
      pointer-events:none;
    }
    .node.active rect, .node.active polygon{
      stroke-width: 2.6;
      fill: rgba(181,255,124,.16);
      stroke: rgba(181,255,124,.85);
    }
    .edge{
      stroke: rgba(233,238,246,.40);
      stroke-width: 2.2;
      fill: none;
      marker-end: url(#arrow);
    }
    .edge.alt{
      stroke: rgba(255,204,102,.55);
      stroke-dasharray: 6 6;
      marker-end: url(#arrowAlt);
    }
    .analogy{
      stroke: rgba(181,255,124,.55);
      stroke-dasharray: 6 6;
      stroke-width: 2;
      marker-end: url(#arrowAnalog);
      marker-start: url(#arrowAnalog);
      opacity: .75;
    }
    .dim{ opacity: .18; }
    .hidden{ display:none; }

    /* Deck */
    .deckWrap{
      display:none;
      height: 100%;
      min-height: 560px;
    }
    .deckWrap.active{ display:block; }

    .slide{
      border: 1px solid var(--line);
      background: rgba(0,0,0,.14);
      border-radius: 14px;
      padding: 16px 16px;
      margin-bottom: 12px;
    }
    .slide h2{
      margin: 0 0 8px;
      font-size: 18px;
      letter-spacing: .2px;
      line-height: 1.2;
    }
    .slide p, .slide li{
      margin: 0;
      font-size: 14.5px;
      line-height: 1.55;
      color: rgba(233,238,246,.92);
    }
    .slide ul{ margin: 10px 0 0; padding-left: 18px; }
    .callout{
      border-left: 3px solid rgba(124,212,255,.8);
      padding: 10px 12px;
      border-radius: 12px;
      background: rgba(124,212,255,.08);
      margin-top: 10px;
    }
    .callout strong{ color: var(--accent); }

    .deckNav{
      position: sticky;
      bottom: 0;
      display:flex;
      justify-content:space-between;
      gap: 10px;
      padding: 10px 12px;
      background: rgba(16,24,38,.92);
      border-top: 1px solid var(--line);
      backdrop-filter: blur(10px);
      margin-top: 12px;
      border-radius: 14px;
    }

    /* Right details panel */
    .right{
      display:flex;
      flex-direction:column;
      min-height:0;
    }
    .rightTop{
      padding: 12px 14px;
      border-bottom: 1px solid var(--line);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
    }
    .rightTop h2{
      margin:0;
      font-size: 14px;
      letter-spacing:.2px;
    }
    .rightBody{
      padding: 12px 14px 14px;
      overflow:auto;
      min-height:0;
    }

    .meta{
      display:flex;
      gap: 8px;
      flex-wrap:wrap;
      margin-bottom: 10px;
    }
    .badge{
      font-size: 12px;
      color: rgba(233,238,246,.86);
      border: 1px solid var(--line);
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(0,0,0,.12);
    }
    .badge.good{ border-color: rgba(181,255,124,.25); background: rgba(181,255,124,.08); }
    .badge.warn{ border-color: rgba(255,204,102,.25); background: rgba(255,204,102,.08); }
    .badge.bad{ border-color: rgba(255,124,156,.25); background: rgba(255,124,156,.08); }

    .hr{
      height: 1px;
      background: var(--line);
      margin: 12px 0;
    }

    .small{
      color: var(--muted);
      font-size: 12.5px;
      line-height: 1.45;
    }
    .big{
      font-size: 16px;
      line-height: 1.55;
      color: rgba(233,238,246,.92);
    }

    footer{
      padding: 10px 18px 14px;
      border-top: 1px solid var(--line);
      background: rgba(16,24,38,.62);
      backdrop-filter: blur(10px);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
      flex-wrap:wrap;
    }
    .progress{
      flex: 1;
      min-width: 220px;
      height: 8px;
      background: rgba(233,238,246,.08);
      border-radius: 999px;
      overflow:hidden;
      border: 1px solid rgba(233,238,246,.10);
    }
    .bar{
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, rgba(124,212,255,.95), rgba(181,255,124,.85));
      transition: width .18s ease;
    }
    .status{
      color: var(--muted);
      font-size: 12px;
      display:flex;
      gap: 10px;
      align-items:center;
      flex-wrap:wrap;
      justify-content:flex-end;
    }
    .status kbd{
      font-family: var(--mono);
      font-size: 11px;
      padding: 2px 6px;
      border: 1px solid var(--line);
      border-radius: 8px;
      color: var(--text);
      background: rgba(0,0,0,.15);
    }
  </style>
</head>

<body>
<div class="app">
  <header>
    <div class="brand">
      <h1 id="hdrTitle">Worker Value & System Ownership</h1>
      <p class="sub" id="hdrSub">Interactive map + deck for talking with Thomas</p>
    </div>
    <div class="controls">
      <select id="lensSelect" title="Change lens (what the details panel emphasizes)">
        <option value="mechanics">Lens: Mechanics</option>
        <option value="governance">Lens: Government</option>
        <option value="ownership">Lens: Ownership vs Access</option>
        <option value="language">Lens: Language traps</option>
      </select>
      <button id="resetBtn" title="Reset highlights and selection">Reset</button>
      <span class="pill" title="Keyboard controls">
        <kbd>M</kbd> Map <kbd>D</kbd> Deck <kbd>←</kbd><kbd>→</kbd>
      </span>
    </div>
  </header>

  <main>
    <div class="stage">
      <!-- LEFT: Map/Deck -->
      <div class="panel left">
        <div class="leftTopbar">
          <div class="modeTabs">
            <div class="tab active" id="tabMap">Map</div>
            <div class="tab" id="tabDeck">Deck</div>
          </div>
          <div class="miniControls">
            <button id="toggleAltBtn" title="Show/hide alternative outcome nodes + edges">Alt outcomes</button>
            <button id="toggleAnalogBtn" title="Show/hide analogy links">Analogies</button>
            <button id="focusPathBtn" title="Highlight current selected path">Focus path</button>
            <select id="eraSelect" title="Which era to emphasize">
              <option value="both">Era: Both</option>
              <option value="civilwar">Era: Civil War chain</option>
              <option value="modern">Era: Modern capital chain</option>
            </select>
          </div>
        </div>

        <div class="viewport">
          <!-- MAP MODE -->
          <div class="mapWrap active" id="mapWrap">
            <div class="mapLegend">
              <span><span class="dot actual"></span>Actual chain</span>
              <span><span class="dot alt"></span>Alternative branch</span>
              <span><span class="dot analogy"></span>Analogy link</span>
              <span class="small">Click nodes → details. Use “Focus path” to dim everything else.</span>
            </div>

            <svg id="mapSvg" viewBox="0 0 980 560" role="img" aria-label="Structural fork map">
              <defs>
                <marker id="arrow" markerWidth="10" markerHeight="10" refX="8" refY="3" orient="auto">
                  <path d="M0,0 L9,3 L0,6 Z" fill="rgba(233,238,246,.55)"></path>
                </marker>
                <marker id="arrowAlt" markerWidth="10" markerHeight="10" refX="8" refY="3" orient="auto">
                  <path d="M0,0 L9,3 L0,6 Z" fill="rgba(255,204,102,.7)"></path>
                </marker>
                <marker id="arrowAnalog" markerWidth="10" markerHeight="10" refX="8" refY="3" orient="auto">
                  <path d="M0,0 L9,3 L0,6 Z" fill="rgba(181,255,124,.75)"></path>
                </marker>
              </defs>

              <!-- edges injected by JS -->
              <g id="edges"></g>

              <!-- nodes injected by JS -->
              <g id="nodes"></g>
            </svg>
          </div>

          <!-- DECK MODE -->
          <div class="deckWrap" id="deckWrap">
            <div id="deck"></div>
            <div class="deckNav">
              <button id="deckPrev">Prev</button>
              <div class="pill" id="deckCounter">1 / 1</div>
              <button id="deckNext">Next</button>
            </div>
          </div>
        </div>
      </div>

      <!-- RIGHT: Details -->
      <div class="panel right">
        <div class="rightTop">
          <h2 id="detailTitle">Details</h2>
          <button id="copyBtn" title="Copy the current node summary">Copy</button>
        </div>
        <div class="rightBody">
          <div class="meta" id="detailMeta"></div>
          <div class="big" id="detailBody">
            Click a node in the map (or step through the deck).<br/>
            This panel will show the explanation using the selected “Lens.”
          </div>
          <div class="hr"></div>
          <div class="small" id="detailFoot">
            Tip: the “Language traps” lens is tailored for the 15-minute city / “own nothing” reactions.
          </div>
        </div>
      </div>
    </div>
  </main>

  <footer>
    <div class="progress" aria-label="progress"><div class="bar" id="bar"></div></div>
    <div class="status">
      <span id="statusText">Mode: Map</span>
      <span><kbd>Esc</kbd> Reset focus</span>
      <span><kbd>A</kbd> Alt</span>
      <span><kbd>G</kbd> Analogies</span>
    </div>
  </footer>
</div>

<script>
(() => {
  // =========================
  // 1) DATA: edit here
  // =========================
  const DATA = {
    deckTitle: "Worker Value & System Ownership",
    deckSubtitle: "Interactive map + deck for talking with Thomas",

    // Nodes: id, era, x,y, type, title, tags, lensText
    nodes: [
      // Civil War chain (actual)
      { id:"cw1", era:"civilwar", x:120, y:70, type:"box", title:"1787 Constitutional Compromise",
        tags:["actual","history"],
        text:{
          mechanics:"Deferred the conflict by embedding slavery into governance compromises.",
          governance:"Shows how ‘coordination’ can include moral debt that compounds.",
          ownership:"People were treated as capital within the legal-economic system.",
          language:"‘Compromise’ sounds neutral; structurally it can be a time-bomb."
        }
      },
      { id:"cw2", era:"civilwar", x:120, y:150, type:"box", title:"1820 Missouri Compromise",
        tags:["actual","balance"],
        text:{
          mechanics:"A postponement strategy: balance expansions rather than resolve fundamentals.",
          governance:"Patchwork governance: stability by delay, not settlement.",
          ownership:"Ownership of people stays intact; access and power expand with territory.",
          language:"‘Balance’ is a soothing word for a widening constraint."
        }
      },
      { id:"cw3d", era:"civilwar", x:120, y:230, type:"decision", title:"Resolve early?",
        tags:["actual","fork"],
        text:{
          mechanics:"Fork point: gradual abolition (different crisis) vs escalation toward war.",
          governance:"Key question: do you centralize moral enforcement or defer to local power?",
          ownership:"If humans can’t be owned, value capture shifts to owning the environment of work.",
          language:"Words like ‘states’ rights’ can hide the object being defended."
        }
      },
      { id:"cw3", era:"civilwar", x:120, y:310, type:"box", title:"1861–65 Civil War",
        tags:["actual","conflict"],
        text:{
          mechanics:"Violent resolution when institutions can’t reconcile incompatible systems.",
          governance:"Shows the danger of ‘only force’ logic: force becomes the policy tool.",
          ownership:"War rearranged who controlled the system, not just the rules.",
          language:"‘War between states’ vs ‘war over slavery’ is a framing fight."
        }
      },
      { id:"cw4", era:"civilwar", x:120, y:390, type:"box", title:"1865 — 13th Amendment",
        tags:["actual","structural-change"],
        text:{
          mechanics:"Removed legal ownership of humans (a category deletion).",
          governance:"A state action that redefines what can be owned—hard boundary-setting.",
          ownership:"Labor becomes sellable; access to systems becomes the new leverage point.",
          language:"‘Freedom’ is real, but economic constraints can persist via other channels."
        }
      },

      // Civil War alternatives (hidden by default)
      { id:"cwAlt1", era:"civilwar", x:420, y:230, type:"alt", title:"Alt: gradual abolition earlier",
        tags:["alt","counterfactual"],
        text:{
          mechanics:"A different crisis profile: less war-scale violence, more sustained political backlash.",
          governance:"Would require persistent enforcement capacity (courts, federal power).",
          ownership:"Shifts value capture sooner toward land/infrastructure rather than people.",
          language:"‘Gradual’ can mean humane transition or prolonged injustice—depends on design."
        }
      },

      // Modern chain (actual)
      { id:"m1", era:"modern", x:640, y:70, type:"box", title:"Capital mobility (late 20th c.)",
        tags:["actual","modern"],
        text:{
          mechanics:"Capital moves faster than labor; bargaining asymmetry rises.",
          governance:"Regulation struggles when capital can exit jurisdictions easily.",
          ownership:"Ownership concentrates in firms/platforms; labor remains local.",
          language:"‘Globalization’ can mean opportunity or exit threat, depending who you are."
        }
      },
      { id:"m2", era:"modern", x:640, y:150, type:"box", title:"Platform concentration",
        tags:["actual","node-ownership"],
        text:{
          mechanics:"Owning bottlenecks (distribution, attention, logistics) beats owning everything.",
          governance:"Antitrust and standards become the battleground.",
          ownership:"Access to markets depends on systems you don’t own.",
          language:"‘Free market’ rhetoric can coexist with very non-free chokepoints."
        }
      },
      { id:"m3d", era:"modern", x:640, y:230, type:"decision", title:"Broaden ownership?",
        tags:["actual","fork"],
        text:{
          mechanics:"Fork: broaden ownership (dividends/employee ownership/public options) vs deeper concentration.",
          governance:"This is where ‘what government does’ matters: stability vs force-only.",
          ownership:"Ownership distribution determines autonomy more than density does.",
          language:"‘Redistribution’ triggers; ‘stability dividend’ describes the same mechanism."
        }
      },
      { id:"m3", era:"modern", x:640, y:310, type:"box", title:"Parallel systems emerge",
        tags:["actual","fragmentation"],
        text:{
          mechanics:"When trust + access fail, people build workarounds: informal economies, alt platforms.",
          governance:"Fragmentation is a stability warning light, not just ‘culture war.’",
          ownership:"If key nodes are owned tightly, parallel systems become survival strategy.",
          language:"‘Opt out’ sounds voluntary until you see who pays the exit cost."
        }
      },
      { id:"m4", era:"modern", x:640, y:390, type:"box", title:"New social contract",
        tags:["actual","settlement"],
        text:{
          mechanics:"A new equilibrium between ownership, access, and baseline security.",
          governance:"The state can be a stability guarantor, not only a force holder.",
          ownership:"People own labor/ideas/products; society decides access terms to infrastructure.",
          language:"This is where ‘UBI’ is one tool among many, not a religion."
        }
      },

      // Modern alternatives
      { id:"mAlt1", era:"modern", x:340, y:230, type:"alt", title:"Alt: broad ownership (co-ops/dividends)",
        tags:["alt","counterfactual"],
        text:{
          mechanics:"Distributes returns from system productivity; reduces desperation bargaining.",
          governance:"Can be implemented as dividends, tax credits, public options, or employee ownership.",
          ownership:"Keeps private property while widening who receives asset-linked income.",
          language:"Avoid ‘you’ll own nothing’ by emphasizing ownership broadening, not eliminating."
        }
      }
    ],

    // Edges: from,to,type
    edges: [
      { from:"cw1", to:"cw2", type:"actual" },
      { from:"cw2", to:"cw3d", type:"actual" },
      { from:"cw3d", to:"cw3", type:"actual" },
      { from:"cw3", to:"cw4", type:"actual" },
      { from:"cw3d", to:"cwAlt1", type:"alt" },

      { from:"m1", to:"m2", type:"actual" },
      { from:"m2", to:"m3d", type:"actual" },
      { from:"m3d", to:"m3", type:"actual" },
      { from:"m3", to:"m4", type:"actual" },
      { from:"m3d", to:"mAlt1", type:"alt" }
    ],

    // Analogy links: bidirectional dashed
    analogies: [
      { a:"cw2", b:"m2", label:"Bottlenecks / balance logic" },
      { a:"cw3d", b:"m3d", label:"Fork: resolve vs defer" },
      { a:"cw4", b:"m4", label:"Structural boundary / new contract" }
    ],

    // Deck slides: linear narration that can deep-link to nodes
    deck: [
      {
        title:"What we’re actually trying to figure out",
        body:[
          "Slavery ended. That’s a huge structural break.",
          "But one systems question survives:",
          "If people can’t be owned, how is value created by labor captured and distributed?"
        ],
        callout:"Separate: physical assets (stuff), ownership (titles/claims), labor (time/skill/ideas/products)."
      },
      {
        title:"Before abolition: labor was a direct asset",
        body:[
          "Humans were treated as capital on balance sheets alongside land and equipment.",
          "Abolition removes the category ‘people as property’ — a category deletion."
        ],
        jump:"cw1"
      },
      {
        title:"After abolition: ownership shifts to systems",
        body:[
          "Value capture moves from owning bodies to owning platforms of work/life:",
          "factories, rails, housing, farms, machines, energy, distribution."
        ],
        jump:"m2"
      },
      {
        title:"The physical substrate of civilization",
        body:[
          "Replacement-cost magnitude: produced assets ~$400–600T; land ~$200–400T; combined ~$700–900T (rough).",
          "Financial claims can stack on the same physical assets — claims > things."
        ],
        jump:"m1"
      },
      {
        title:"The structural fork we keep arguing about",
        body:[
          "Not ‘markets vs no markets.’",
          "It’s: how much system productivity feeds back into baseline security so participation stays possible without coercion.",
          "UBI is one tool; dividends, tax credits, employee ownership, and public options are others."
        ],
        jump:"m3d",
        callout:"If someone fears ‘own nothing,’ emphasize broadening ownership and access, not eliminating property."
      }
    ]
  };

  // =========================
  // 2) STATE
  // =========================
  let mode = "map";              // "map" | "deck"
  let lens = "mechanics";        // selected lens
  let showAlt = false;
  let showAnalogies = true;
  let eraFocus = "both";         // "both" | "civilwar" | "modern"
  let focusPath = false;
  let selectedNodeId = null;

  // Deck state
  let deckIndex = 0;

  // DOM
  const hdrTitle = document.getElementById("hdrTitle");
  const hdrSub = document.getElementById("hdrSub");
  const statusText = document.getElementById("statusText");
  const bar = document.getElementById("bar");

  const tabMap = document.getElementById("tabMap");
  const tabDeck = document.getElementById("tabDeck");
  const mapWrap = document.getElementById("mapWrap");
  const deckWrap = document.getElementById("deckWrap");

  const edgesG = document.getElementById("edges");
  const nodesG = document.getElementById("nodes");

  const lensSelect = document.getElementById("lensSelect");
  const eraSelect = document.getElementById("eraSelect");

  const toggleAltBtn = document.getElementById("toggleAltBtn");
  const toggleAnalogBtn = document.getElementById("toggleAnalogBtn");
  const focusPathBtn = document.getElementById("focusPathBtn");
  const resetBtn = document.getElementById("resetBtn");
  const copyBtn = document.getElementById("copyBtn");

  const detailTitle = document.getElementById("detailTitle");
  const detailMeta = document.getElementById("detailMeta");
  const detailBody = document.getElementById("detailBody");
  const detailFoot = document.getElementById("detailFoot");

  const deckDiv = document.getElementById("deck");
  const deckPrev = document.getElementById("deckPrev");
  const deckNext = document.getElementById("deckNext");
  const deckCounter = document.getElementById("deckCounter");

  // =========================
  // 3) HELPERS
  // =========================
  const byId = Object.fromEntries(DATA.nodes.map(n => [n.id, n]));

  function setHeader(title, sub){
    hdrTitle.textContent = title;
    hdrSub.textContent = sub;
  }

  function badge(text, cls=""){
    const s = document.createElement("span");
    s.className = "badge " + cls;
    s.textContent = text;
    return s;
  }

  function renderDetails(node){
    if(!node){
      detailTitle.textContent = "Details";
      detailMeta.innerHTML = "";
      detailBody.innerHTML = "Click a node in the map (or step through the deck).<br/>This panel will show the explanation using the selected “Lens.”";
      detailFoot.textContent = "Tip: the “Language traps” lens is tailored for the 15-minute city / “own nothing” reactions.";
      return;
    }

    detailTitle.textContent = node.title;
    detailMeta.innerHTML = "";
    detailMeta.appendChild(badge(node.era === "civilwar" ? "Civil War chain" : "Modern chain", "good"));
    node.tags.forEach(t => {
      const cls = (t === "alt") ? "warn" : (t === "actual" ? "good" : "");
      detailMeta.appendChild(badge(t, cls));
    });
    detailMeta.appendChild(badge("lens: " + lens, ""));

    const txt = (node.text && node.text[lens]) ? node.text[lens] : "(No text for this lens yet.)";
    detailBody.textContent = txt;

    // context footer that shifts per lens
    const lensFoot = {
      mechanics: "Mechanics lens: how value and constraints move through systems.",
      governance: "Government lens: what coordination does, and where force-risk hides.",
      ownership: "Ownership lens: ownership vs access vs autonomy.",
      language: "Language lens: why certain terms trigger fear even when structures are similar."
    };
    detailFoot.textContent = lensFoot[lens] || "";
  }

  function svgEl(tag, attrs={}){
    const el = document.createElementNS("http://www.w3.org/2000/svg", tag);
    Object.entries(attrs).forEach(([k,v]) => el.setAttribute(k, v));
    return el;
  }

  function drawNode(n){
    const g = svgEl("g", { class:`node ${n.type === "decision" ? "decision":""} ${n.type === "alt" ? "alt":""}`, "data-id": n.id });
    g.setAttribute("transform", `translate(${n.x},${n.y})`);

    if(n.type === "decision"){
      const poly = svgEl("polygon", { points:"120,0 240,32 120,64 0,32" });
      g.appendChild(poly);
      const text = svgEl("text", { x:"120", y:"38", "text-anchor":"middle" });
      text.textContent = n.title;
      g.appendChild(text);
    } else {
      const rect = svgEl("rect", { width:"240", height:"64", rx:"12" });
      g.appendChild(rect);
      const text = svgEl("text", { x:"120", y:"38", "text-anchor":"middle" });
      text.textContent = n.title;
      g.appendChild(text);
    }

    g.addEventListener("click", () => selectNode(n.id, {from:"map"}));
    return g;
  }

  function nodeCenter(n){
    // node box ~ 240x64; decision diamond ~240x64 visually
    return { cx: n.x + 120, cy: n.y + 32 };
  }

  function drawEdge(e){
    const a = byId[e.from], b = byId[e.to];
    if(!a || !b) return null;
    const A = nodeCenter(a), B = nodeCenter(b);

    // route: mostly vertical lines within columns; add simple dogleg if cross-column
    const sameColumn = Math.abs(A.cx - B.cx) < 40;
    let d;
    if(sameColumn){
      d = `M ${A.cx} ${A.cy+32} L ${B.cx} ${B.cy-32}`;
    } else {
      const midY = (A.cy + B.cy)/2;
      d = `M ${A.cx} ${A.cy} L ${A.cx} ${midY} L ${B.cx} ${midY} L ${B.cx} ${B.cy}`;
    }

    const path = svgEl("path", { d, class: `edge ${e.type === "alt" ? "alt":""}` });
    return path;
  }

  function drawAnalogy(link){
    const a = byId[link.a], b = byId[link.b];
    if(!a || !b) return null;
    const A = nodeCenter(a), B = nodeCenter(b);
    const d = `M ${A.cx+120} ${A.cy} L ${B.cx-120} ${B.cy}`;
    return svgEl("path", { d, class:"analogy" });
  }

  function applyVisibility(){
    // Alt nodes/edges
    document.querySelectorAll(".node.alt").forEach(el => {
      el.classList.toggle("hidden", !showAlt);
    });
    document.querySelectorAll(".edge.alt").forEach(el => {
      el.classList.toggle("hidden", !showAlt);
    });

    // Analogy links
    document.querySelectorAll(".analogy").forEach(el => {
      el.classList.toggle("hidden", !showAnalogies);
    });

    // Era focus dims the other era
    DATA.nodes.forEach(n => {
      const el = nodesG.querySelector(`[data-id="${CSS.escape(n.id)}"]`);
      if(!el) return;
      const dim = (eraFocus !== "both" && n.era !== eraFocus);
      el.classList.toggle("dim", dim);
    });

    // Focus path dims everything except nodes on a chosen path (simple: selected node's era chain)
    if(focusPath && selectedNodeId){
      const keep = new Set();
      const start = selectedNodeId;

      // Walk upstream + downstream along actual edges
      const actualEdges = DATA.edges.filter(x => x.type === "actual");
      function walkForward(id){
        keep.add(id);
        actualEdges.filter(x => x.from === id).forEach(x => walkForward(x.to));
      }
      function walkBackward(id){
        keep.add(id);
        actualEdges.filter(x => x.to === id).forEach(x => walkBackward(x.from));
      }
      walkForward(start);
      walkBackward(start);

      DATA.nodes.forEach(n => {
        const el = nodesG.querySelector(`[data-id="${CSS.escape(n.id)}"]`);
        if(!el) return;
        const shouldKeep = keep.has(n.id);
        // don’t hide other-era entirely; just dim
        el.classList.toggle("dim", !shouldKeep);
      });

      // Dim edges not in keep
      edgesG.querySelectorAll("path.edge").forEach(p => p.classList.add("dim"));
      actualEdges.forEach(e => {
        if(keep.has(e.from) && keep.has(e.to)){
          const key = `${e.from}::${e.to}::${e.type}`;
          const p = edgesG.querySelector(`[data-key="${CSS.escape(key)}"]`);
          if(p) p.classList.remove("dim");
        }
      });

      // Keep analogies if enabled but dim if not connected
      edgesG.querySelectorAll("path.analogy").forEach(p => p.classList.toggle("dim", false));
    } else {
      edgesG.querySelectorAll("path.edge").forEach(p => p.classList.remove("dim"));
      // restore era dim only
      DATA.nodes.forEach(n => {
        const el = nodesG.querySelector(`[data-id="${CSS.escape(n.id)}"]`);
        if(!el) return;
        const dim = (eraFocus !== "both" && n.era !== eraFocus);
        el.classList.toggle("dim", dim);
      });
    }
  }

  function selectNode(id, {from} = {}){
    selectedNodeId = id;

    // active class
    nodesG.querySelectorAll(".node").forEach(el => el.classList.remove("active"));
    const el = nodesG.querySelector(`[data-id="${CSS.escape(id)}"]`);
    if(el) el.classList.add("active");

    // details
    renderDetails(byId[id]);

    // progress bar: if we’re in deck, show deck progress; otherwise show map progress by "depth" in era
    if(mode === "deck"){
      const pct = ((deckIndex+1) / DATA.deck.length) * 100;
      bar.style.width = pct.toFixed(2) + "%";
    } else {
      const node = byId[id];
      const chain = node?.era === "civilwar"
        ? ["cw1","cw2","cw3d","cw3","cw4"]
        : ["m1","m2","m3d","m3","m4"];
      const i = Math.max(0, chain.indexOf(id));
      const pct = ((i+1) / chain.length) * 100;
      bar.style.width = pct.toFixed(2) + "%";
    }

    // update status line
    if(from === "deck"){
      statusText.textContent = `Mode: Deck • Selected: ${byId[id]?.title || id}`;
    } else {
      statusText.textContent = `Mode: Map • Selected: ${byId[id]?.title || id}`;
    }

    applyVisibility();
  }

  function resetAll(){
    showAlt = false;
    showAnalogies = true;
    eraFocus = "both";
    focusPath = false;
    selectedNodeId = null;

    // UI sync
    eraSelect.value = "both";
    renderDetails(null);
    nodesG.querySelectorAll(".node").forEach(el => el.classList.remove("active"));
    edgesG.querySelectorAll("path").forEach(p => p.classList.remove("dim"));

    applyVisibility();
    bar.style.width = "0%";
    statusText.textContent = `Mode: ${mode === "map" ? "Map" : "Deck"}`;
  }

  // =========================
  // 4) RENDER MAP
  // =========================
  function renderMap(){
    edgesG.innerHTML = "";
    nodesG.innerHTML = "";

    // edges first
    DATA.edges.forEach(e => {
      const path = drawEdge(e);
      if(!path) return;
      path.setAttribute("data-key", `${e.from}::${e.to}::${e.type}`);
      edgesG.appendChild(path);
    });

    // analogies
    DATA.analogies.forEach(a => {
      const p = drawAnalogy(a);
      if(p) edgesG.appendChild(p);
    });

    // nodes
    DATA.nodes.forEach(n => nodesG.appendChild(drawNode(n)));

    applyVisibility();
  }

  // =========================
  // 5) RENDER DECK
  // =========================
  function renderDeck(){
    deckDiv.innerHTML = "";
    DATA.deck.forEach((s, i) => {
      const slide = document.createElement("div");
      slide.className = "slide";
      slide.setAttribute("data-index", String(i));

      const h2 = document.createElement("h2");
      h2.textContent = `${i+1}. ${s.title}`;
      slide.appendChild(h2);

      s.body.forEach(line => {
        const p = document.createElement("p");
        p.style.marginTop = "8px";
        p.textContent = line;
        slide.appendChild(p);
      });

      if(s.callout){
        const c = document.createElement("div");
        c.className = "callout";
        c.innerHTML = `<strong>Key idea:</strong> ${escapeHtml(s.callout)}`;
        slide.appendChild(c);
      }

      if(s.jump){
        const btn = document.createElement("button");
        btn.textContent = "Jump to related node";
        btn.style.marginTop = "10px";
        btn.addEventListener("click", () => {
          switchMode("map");
          selectNode(s.jump, {from:"deck"});
        });
        slide.appendChild(btn);
      }

      deckDiv.appendChild(slide);
    });

    updateDeckNav();
  }

  function updateDeckNav(){
    deckCounter.textContent = `${deckIndex+1} / ${DATA.deck.length}`;
    const pct = ((deckIndex+1) / DATA.deck.length) * 100;
    bar.style.width = pct.toFixed(2) + "%";
    statusText.textContent = `Mode: Deck • Slide ${deckIndex+1}/${DATA.deck.length}`;
    // Scroll to active slide
    const active = deckDiv.querySelector(`.slide[data-index="${deckIndex}"]`);
    if(active) active.scrollIntoView({behavior:"smooth", block:"start"});
    // Also select linked node if present
    const jump = DATA.deck[deckIndex]?.jump;
    if(jump) selectNode(jump, {from:"deck"});
    else renderDetails(null);
  }

  function escapeHtml(str){
    return (str || "")
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;")
      .replaceAll("'","&#039;");
  }

  // =========================
  // 6) MODE SWITCHING
  // =========================
  function switchMode(newMode){
    mode = newMode;

    const isMap = (mode === "map");
    tabMap.classList.toggle("active", isMap);
    tabDeck.classList.toggle("active", !isMap);
    mapWrap.classList.toggle("active", isMap);
    deckWrap.classList.toggle("active", !isMap);

    statusText.textContent = `Mode: ${isMap ? "Map" : "Deck"}`;

    if(isMap){
      // keep current selection if any
      if(selectedNodeId) selectNode(selectedNodeId, {from:"map"});
      else bar.style.width = "0%";
    } else {
      updateDeckNav();
    }
  }

  // =========================
  // 7) UI EVENTS
  // =========================
  lensSelect.addEventListener("change", (e) => {
    lens = e.target.value;
    if(selectedNodeId) renderDetails(byId[selectedNodeId]);
  });

  eraSelect.addEventListener("change", (e) => {
    eraFocus = e.target.value;
    applyVisibility();
  });

  toggleAltBtn.addEventListener("click", () => {
    showAlt = !showAlt;
    applyVisibility();
  });

  toggleAnalogBtn.addEventListener("click", () => {
    showAnalogies = !showAnalogies;
    applyVisibility();
  });

  focusPathBtn.addEventListener("click", () => {
    focusPath = !focusPath;
    applyVisibility();
  });

  resetBtn.addEventListener("click", resetAll);

  copyBtn.addEventListener("click", async () => {
    const node = selectedNodeId ? byId[selectedNodeId] : null;
    const txt = node ? `${node.title}\n\n(${lens} lens)\n${node.text?.[lens] || ""}` : "No node selected.";
    try{
      await navigator.clipboard.writeText(txt);
      copyBtn.textContent = "Copied";
      setTimeout(()=>copyBtn.textContent="Copy", 900);
    }catch{
      copyBtn.textContent = "Copy failed";
      setTimeout(()=>copyBtn.textContent="Copy", 900);
    }
  });

  tabMap.addEventListener("click", () => switchMode("map"));
  tabDeck.addEventListener("click", () => switchMode("deck"));

  deckPrev.addEventListener("click", () => { deckIndex = Math.max(0, deckIndex-1); updateDeckNav(); });
  deckNext.addEventListener("click", () => { deckIndex = Math.min(DATA.deck.length-1, deckIndex+1); updateDeckNav(); });

  // Keyboard
  window.addEventListener("keydown", (e) => {
    const k = e.key.toLowerCase();
    if(k === "m") switchMode("map");
    if(k === "d") switchMode("deck");
    if(k === "a"){ showAlt = !showAlt; applyVisibility(); }
    if(k === "g"){ showAnalogies = !showAnalogies; applyVisibility(); }
    if(k === "escape"){ focusPath = false; eraFocus = "both"; eraSelect.value = "both"; applyVisibility(); }

    if(mode === "deck"){
      if(e.key === "ArrowRight" || e.key === " " || e.key === "PageDown"){ e.preventDefault(); deckIndex = Math.min(DATA.deck.length-1, deckIndex+1); updateDeckNav(); }
      if(e.key === "ArrowLeft"  || e.key === "Backspace" || e.key === "PageUp"){ e.preventDefault(); deckIndex = Math.max(0, deckIndex-1); updateDeckNav(); }
    } else {
      // In map mode, arrows step through the “actual” chain of the selected node’s era
      if(!selectedNodeId) return;
      const node = byId[selectedNodeId];
      const chain = node?.era === "civilwar"
        ? ["cw1","cw2","cw3d","cw3","cw4"]
        : ["m1","m2","m3d","m3","m4"];
      let i = chain.indexOf(selectedNodeId);
      if(i < 0) return;
      if(e.key === "ArrowRight"){ i = Math.min(chain.length-1, i+1); selectNode(chain[i], {from:"map"}); }
      if(e.key === "ArrowLeft"){ i = Math.max(0, i-1); selectNode(chain[i], {from:"map"}); }
    }
  });

  // =========================
  // 8) INIT
  // =========================
  setHeader(DATA.deckTitle, DATA.deckSubtitle);
  renderMap();
  renderDeck();
  renderDetails(null);
  bar.style.width = "0%";

  // Optional: preselect a useful starting node (modern fork)
  selectNode("m3d", {from:"map"});

})();
</script>
</body>
</html>